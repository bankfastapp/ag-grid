---
title: "Tree Data - Row Dragging"
enterprise: true
---
Configure the grid to display structured data by providing data paths.

## Enabling Row Dragging

Row Dragging can be combined with Tree Data to let users reorder rows within a hierarchical structure. You can choose between two approaches:

- [Managed Row Dragging](#enabling-managed-row-dragging): The grid handles row dragging automatically.
- [Unmanaged Row Dragging](#unmanaged-row-dragging): Customized application specific logic for row dragging.

To enable row dragging, set `rowDrag: true` on the group column (usually via `autoGroupColumnDef`).

```{% frameworkTransform=true %}
const gridOptions = {
    treeData: true,
    autoGroupColumnDef: {
        field: 'name',
        rowDrag: true // Enable row dragging on the group column
    },
    // ...other options
};
```

See the [Row Dragging](./row-dragging/) documentation for more information about row dragging options, APIs, and advanced usage.

## Enabling Managed Row Dragging

This is the simplest way to enable row dragging with Tree Data.
The grid will automatically handle the dragging of rows and updating the data structure.
It supports reordering, moving parents and children, and converting a leaf node into a group.

To enable managed row dragging, set the following options:

- `treeData: true` — Enables tree data mode, allowing hierarchical data structures.
- `getRowId` — Provides a unique ID for each row, required for row movement.
- `treeDataParentIdField: 'parentId'` — Specifies the field that defines parent-child relationships.
- `rowDragManaged: true` — Enables managed row dragging, so the grid handles row movement automatically.
- `rowDragInsertDelay` — Delay before expanding a collapsed group or converting a leaf to a group (see [Row Drag Insert Delay](#row-drag-insert-delay)).
- `autoGroupColumnDef.rowDrag: true` — Enables the drag handle in the group column.
- `groupDefaultExpanded: -1` — Expands all groups by default.
- `suppressMoveWhenRowDragging: true` — Prevents the grid from moving rows while dragging, showing a highlight over the row instead.

```{% frameworkTransform=true %}
const gridOptions = {
    treeData: true,
    getRowId: params => params.data.id,
    treeDataParentIdField: 'parentId',
    rowDragManaged: true,
    rowDragInsertDelay: 500, // optional
    groupDefaultExpanded: -1,
    suppressMoveWhenRowDragging: true,
    autoGroupColumnDef: {
        field: 'name',
        rowDrag: true
    },
    // ...other options
};
```

{% note %}
It is recommended to enable `suppressMoveWhenRowDragging` when using managed row dragging with Tree Data.
Without this option, moving subtrees can cause the grid to jump or scroll unexpectedly as rows are repositioned during the drag.
Enabling it provides a smoother and more predictable user experience by only highlighting the drop target without moving rows until the drop is complete.
{% /note %}

{% gridExampleRunner title="Managed Row Drag with Tree Data" name="tree-managed-row-drag"  exampleHeight=545 /%}

### Managed Row Dragging with getDataPath

This next examples shows how to use the `getDataPath` callback to define the hierarchical structure of the data.

{% note %}
This example uses filler nodes (where some intermediate path segments do not exist as explicit nodes in the data).
Empty filler nodes cannot exist in the grid; if all their children are moved out, the filler node will be deleted and disappear.
It is instead recommended to provide a full grid without filler nodes to avoid this.
See the [Providing Data Paths](./tree-data-paths) for details about filler nodes ans `getDataPath`.
{% /note %}

{% gridExampleRunner title="Managed Row Drag with Tree Data (getDataPath)" name="tree-managed-row-drag-data-path" exampleHeight=500 /%}

### Row Drag Insert Delay

When using Tree Data with Managed Row Dragging, the `rowDragInsertDelay` grid option sets a delay (in milliseconds) before a dragged row is inserted into a new parent node.
The default value is `500` milliseconds.
This delay helps prevent accidental moves when hovering over potential drop targets. If the target is a collapsed parent or a leaf node, the grid will expand the parent or convert the leaf into a parent after this delay, allowing the dragged row to be inserted as a child.

## Unmanaged Row Dragging 

To have full control, is possible to provide a customized implementation of row dragging using unmanaged row dragging.
The application in this case is fully responsible to maintain the rowData state and handling the dragging events and updating the rowData based on the drag events fired by the grid.

### Example Tree Data Unmanaged Row Dragging

The example below shows [Tree Data](./tree-data/) and row dragging with getDataPath where the following can be noted:

* The [auto-group column](./grouping/) has row drag `true` for all rows.
* The application moves the rows in the row data while the row drag is happening in the `onRowDragMove` event handler.
* While row dragging the row move operation can be reverted by pressing {% kbd "⎋ Escape" /%} key.
* You can reorder a row only inside its current parent by holding the {% kbd "⇧ Shift" /%} key press and dragging it
* The expanded/contracted state of a folder and all of its child folders is preserved when the folder is moved to a new parent.

### Example Highlighted Tree Data Unmanaged Row Dragging

The example above works, however it is not intuitive as the user is given no visual hint what folder will be the destination folder. The example below continues with the example above by providing hints to the user while the drag is in progress. From the example the following can be observed:

* The example registers for `onRowDragMove` events and works out what folder the mouse is over as the drag is happening.

* While the row is dragging, the application highlights the folder that is currently selected as the destination folder (called `potentialParent` in the example code).

* The application does NOT rearrange the rows as the drag is happening. As with the previous example, it waits for the `onRowDragEnd` event before updating the data.

* The example uses [Cell Class Rules](./cell-styles/#cell-class-rules) to highlight the destination folder. The example adds a CSS class `hover-over` to all the cells of the destination folder.

* The example uses [Refresh Cells](./view-refresh/#refresh-cells) to get the grid to execute the Cell Class Rules again over the destination folder when the destination folder changes.

{% gridExampleRunner title="Highlighting Unmanaged Row Drag with Tree Data" name="tree-unmanaged-row-drag-highlight"  /%}

### Example Tree Data with parentId Unmanaged Row Dragging

{% gridExampleRunner title="Unmanaged Row Drag with Tree Data" name="tree-unmanaged-row-drag"  exampleHeight=545  /%}

The following example shows how to implement unmanaged row dragging using the `parentId` approach, which is simpler and more direct than using `getDataPath`. The grid uses the `treeDataParentIdField` property, and utility functions are provided to move rows and update the tree structure. This approach is recommended for most use cases where your data is already structured with parent IDs.

This example also demonstrates how to provide custom drop indicators using the [`setRowDropPositionIndicator`](https://www.ag-grid.com/javascript-data-grid/grid-api/#reference-setRowDropPositionIndicator) API.

{% gridExampleRunner title="Unmanaged Row Drag with parentId" name="tree-unmanaged-row-drag-with-parent-id" exampleHeight=500  /%}

